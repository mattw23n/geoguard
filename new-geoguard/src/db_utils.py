# src/db_utils.py
import json
import os
import uuid
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional, Tuple

from supabase import create_client, Client

SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_KEY = os.getenv("SUPABASE_KEY")

# Check if credentials are provided
if not SUPABASE_URL or not SUPABASE_KEY:
    raise EnvironmentError("SUPABASE_URL and SUPABASE_KEY must be set in your environment variables.")

supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

# ============================ Features ==============================

def get_all_features() -> List[Dict[str, Any]]:
    """Fetches all features from the database, ordered by creation date."""
    try:
        response = supabase.table("features").select("*").order("created_at", desc=True).execute()
        return response.data
    except Exception as e:
        print(f"Error fetching features: {e}")
        return []

def get_feature_by_id(feature_id: str) -> Optional[Dict[str, Any]]:
    """Fetches a single feature by its ID."""
    try:
        response = supabase.table("features").select("*").eq("id", feature_id).single().execute()
        return response.data
    except Exception as e:
        print(f"Error fetching feature {feature_id}: {e}")
        return None

def add_or_update_feature(feature_details: Dict[str, Any]) -> str:
    """
    Add a new feature or update an existing one in the Supabase 'features' table.
    Returns the feature id.
    """
    feature_id = feature_details.get("id")

    # Prepare data for upsert, removing the ID if it's None
    data_to_upsert = {k: v for k, v in feature_details.items() if k != "id" or v is not None}

    try:
        if feature_id:
            # Update existing feature
            response = supabase.table("features").update(data_to_upsert).eq("id", feature_id).execute()
            return response.data[0]['id']
        else:
            # Insert new feature, the ID is auto-generated by the database
            response = supabase.table("features").insert(data_to_upsert).execute()
            return response.data[0]['id']
    except Exception as e:
        print(f"Error adding or updating feature: {e}")
        raise

def delete_features(feature_ids: List[str]) -> Tuple[int, int]:
    """
    Delete features by id. The ON DELETE CASCADE in the database schema
    will automatically delete all associated scans.
    Returns (deleted_features_count, number of scans that will be deleted).
    """
    if not feature_ids:
        return 0, 0

    try:
        # We don't need to count scans manually, but we can for the return value
        scans_to_delete_res = supabase.table("scans").select("scan_id", count='exact').in_("feature_id", feature_ids).execute()
        deleted_scans_count = scans_to_delete_res.count

        # Delete features, scans are deleted by the database cascade
        features_res = supabase.table("features").delete().in_("id", feature_ids).execute()
        deleted_features_count = len(features_res.data)

        return deleted_features_count, deleted_scans_count
    except Exception as e:
        print(f"Error deleting features: {e}")
        return 0, 0


# ============================== Scans ===============================

def add_scan(
    feature_id: str,
    feature_snapshot: Dict[str, Any],
    analysis: Dict[str, Any],
    *,
    audit_meta: Optional[Dict[str, Any]] = None,
    version: Optional[str] = "v1"
) -> str:
    """
    Append a new scan entry for a feature to the Supabase 'scans' table.
    Returns the new scan_id.
    """
    scan_entry = {
        "feature_id": feature_id,
        "version": version,
        "feature_snapshot": feature_snapshot,
        "analysis": analysis,
    }

    if audit_meta:
        allowed_keys = {
            "audit_id", "status", "model", "raw_output_hash",
            "legal_db_fingerprint", "rules_context_ids",
            "rules_context_fingerprint", "prompt_included", "context_text_included", "prompt_snapshot", "context_snapshot",
        }
        scan_entry["audit"] = {k: v for k, v in audit_meta.items() if k in allowed_keys}

    try:
        response = supabase.table("scans").insert(scan_entry).execute()
        return response.data[0]['scan_id']
    except Exception as e:
        print(f"Error adding scan: {e}")
        raise

def get_scans_for_feature(feature_id: str) -> List[Dict[str, Any]]:
    """
    Return scans for a feature from Supabase, sorted newest-first.
    """
    try:
        response = supabase.table("scans").select("*").eq("feature_id", feature_id).order("timestamp_utc", desc=True).execute()
        return response.data
    except Exception as e:
        print(f"Error fetching scans for feature {feature_id}: {e}")
        return []